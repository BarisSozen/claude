// This file is auto-generated by tonic-build at compile time.
// For development, we include manual definitions that match the proto.
// In production builds, tonic-build will generate this file.

#![allow(clippy::all)]
#![allow(unused_imports)]

use prost::Message;
use tonic::{Request, Response, Status, Streaming};

// Chain enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Chain {
    Unknown = 0,
    Ethereum = 1,
    Arbitrum = 2,
    Base = 3,
    Polygon = 4,
}

// DexProtocol enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DexProtocol {
    Unknown = 0,
    UniswapV2 = 1,
    UniswapV3 = 2,
    Sushiswap = 3,
    Curve = 4,
    Balancer = 5,
    AaveV3 = 6,
}

// ExecutionStatus enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    Unknown = 0,
    Pending = 1,
    Submitted = 2,
    Confirmed = 3,
    Failed = 4,
    Reverted = 5,
}

// Token message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Token {
    #[prost(string, tag = "1")]
    pub address: String,
    #[prost(string, tag = "2")]
    pub symbol: String,
    #[prost(uint32, tag = "3")]
    pub decimals: u32,
    #[prost(enumeration = "Chain", tag = "4")]
    pub chain: i32,
}

// TokenAmount message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenAmount {
    #[prost(message, optional, tag = "1")]
    pub token: Option<Token>,
    #[prost(string, tag = "2")]
    pub amount: String,
    #[prost(double, tag = "3")]
    pub amount_usd: f64,
}

// Price operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPriceRequest {
    #[prost(string, tag = "1")]
    pub token_address: String,
    #[prost(enumeration = "Chain", tag = "2")]
    pub chain: i32,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPriceResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(double, tag = "2")]
    pub price_usd: f64,
    #[prost(uint64, tag = "3")]
    pub timestamp_ms: u64,
    #[prost(string, tag = "4")]
    pub source: String,
    #[prost(string, tag = "5")]
    pub error: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamPricesRequest {
    #[prost(string, repeated, tag = "1")]
    pub token_addresses: Vec<String>,
    #[prost(enumeration = "Chain", tag = "2")]
    pub chain: i32,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceUpdate {
    #[prost(string, tag = "1")]
    pub token_address: String,
    #[prost(enumeration = "Chain", tag = "2")]
    pub chain: i32,
    #[prost(double, tag = "3")]
    pub price_usd: f64,
    #[prost(uint64, tag = "4")]
    pub timestamp_ms: u64,
    #[prost(string, tag = "5")]
    pub source: String,
}

// Opportunity operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOpportunitiesRequest {
    #[prost(enumeration = "Chain", repeated, tag = "1")]
    pub chains: Vec<i32>,
    #[prost(double, tag = "2")]
    pub min_profit_usd: f64,
    #[prost(double, tag = "3")]
    pub min_confidence: f64,
    #[prost(int32, tag = "4")]
    pub limit: i32,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOpportunitiesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, repeated, tag = "2")]
    pub opportunities: Vec<ArbitrageOpportunity>,
    #[prost(uint64, tag = "3")]
    pub scan_duration_us: u64,
    #[prost(string, tag = "4")]
    pub error: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOpportunitiesRequest {
    #[prost(enumeration = "Chain", repeated, tag = "1")]
    pub chains: Vec<i32>,
    #[prost(double, tag = "2")]
    pub min_profit_usd: f64,
    #[prost(double, tag = "3")]
    pub min_confidence: f64,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArbitrageOpportunity {
    #[prost(string, tag = "1")]
    pub id: String,
    #[prost(enumeration = "Chain", tag = "2")]
    pub chain: i32,
    #[prost(string, tag = "3")]
    pub token_pair: String,
    #[prost(message, repeated, tag = "4")]
    pub route: Vec<SwapStep>,
    #[prost(message, optional, tag = "5")]
    pub input_amount: Option<TokenAmount>,
    #[prost(message, optional, tag = "6")]
    pub output_amount: Option<TokenAmount>,
    #[prost(double, tag = "7")]
    pub profit_usd: f64,
    #[prost(double, tag = "8")]
    pub profit_bps: f64,
    #[prost(double, tag = "9")]
    pub confidence: f64,
    #[prost(uint64, tag = "10")]
    pub gas_estimate: u64,
    #[prost(double, tag = "11")]
    pub gas_cost_usd: f64,
    #[prost(uint64, tag = "12")]
    pub expires_at_ms: u64,
    #[prost(uint64, tag = "13")]
    pub detected_at_ms: u64,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapStep {
    #[prost(enumeration = "DexProtocol", tag = "1")]
    pub dex: i32,
    #[prost(string, tag = "2")]
    pub pool_address: String,
    #[prost(message, optional, tag = "3")]
    pub token_in: Option<Token>,
    #[prost(message, optional, tag = "4")]
    pub token_out: Option<Token>,
    #[prost(string, tag = "5")]
    pub amount_in: String,
    #[prost(string, tag = "6")]
    pub amount_out: String,
    #[prost(double, tag = "7")]
    pub price_impact_bps: f64,
}

// Simulation operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTradeRequest {
    #[prost(enumeration = "Chain", tag = "1")]
    pub chain: i32,
    #[prost(string, tag = "2")]
    pub delegation_id: String,
    #[prost(enumeration = "DexProtocol", tag = "3")]
    pub protocol: i32,
    #[prost(string, tag = "4")]
    pub token_in: String,
    #[prost(string, tag = "5")]
    pub token_out: String,
    #[prost(string, tag = "6")]
    pub amount_in: String,
    #[prost(string, tag = "7")]
    pub min_amount_out: String,
    #[prost(uint32, tag = "8")]
    pub slippage_bps: u32,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTradeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub would_succeed: bool,
    #[prost(string, tag = "3")]
    pub expected_output: String,
    #[prost(double, tag = "4")]
    pub expected_output_usd: f64,
    #[prost(double, tag = "5")]
    pub price_impact_bps: f64,
    #[prost(uint64, tag = "6")]
    pub gas_estimate: u64,
    #[prost(double, tag = "7")]
    pub gas_cost_usd: f64,
    #[prost(string, tag = "8")]
    pub error: String,
    #[prost(string, tag = "9")]
    pub revert_reason: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateRouteRequest {
    #[prost(enumeration = "Chain", tag = "1")]
    pub chain: i32,
    #[prost(message, repeated, tag = "2")]
    pub route: Vec<SwapStep>,
    #[prost(string, tag = "3")]
    pub input_amount: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateRouteResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub would_succeed: bool,
    #[prost(string, tag = "3")]
    pub final_output: String,
    #[prost(double, tag = "4")]
    pub total_price_impact_bps: f64,
    #[prost(uint64, tag = "5")]
    pub total_gas_estimate: u64,
    #[prost(message, repeated, tag = "6")]
    pub step_results: Vec<StepResult>,
    #[prost(string, tag = "7")]
    pub error: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepResult {
    #[prost(uint32, tag = "1")]
    pub step_index: u32,
    #[prost(bool, tag = "2")]
    pub success: bool,
    #[prost(string, tag = "3")]
    pub output_amount: String,
    #[prost(uint64, tag = "4")]
    pub gas_used: u64,
    #[prost(string, tag = "5")]
    pub error: String,
}

// Execution operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTradeRequest {
    #[prost(enumeration = "Chain", tag = "1")]
    pub chain: i32,
    #[prost(string, tag = "2")]
    pub delegation_id: String,
    #[prost(string, tag = "3")]
    pub opportunity_id: String,
    #[prost(enumeration = "DexProtocol", tag = "4")]
    pub protocol: i32,
    #[prost(string, tag = "5")]
    pub token_in: String,
    #[prost(string, tag = "6")]
    pub token_out: String,
    #[prost(string, tag = "7")]
    pub amount_in: String,
    #[prost(string, tag = "8")]
    pub min_amount_out: String,
    #[prost(uint32, tag = "9")]
    pub slippage_bps: u32,
    #[prost(uint64, tag = "10")]
    pub deadline_ms: u64,
    #[prost(bool, tag = "11")]
    pub use_flashbots: bool,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTradeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub tx_hash: String,
    #[prost(string, tag = "3")]
    pub trade_id: String,
    #[prost(enumeration = "ExecutionStatus", tag = "4")]
    pub status: i32,
    #[prost(string, tag = "5")]
    pub error: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTradeStatusRequest {
    #[prost(string, tag = "1")]
    pub trade_id: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTradeStatusResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub trade_id: String,
    #[prost(enumeration = "ExecutionStatus", tag = "3")]
    pub status: i32,
    #[prost(string, tag = "4")]
    pub tx_hash: String,
    #[prost(uint64, tag = "5")]
    pub block_number: u64,
    #[prost(uint64, tag = "6")]
    pub gas_used: u64,
    #[prost(string, tag = "7")]
    pub actual_output: String,
    #[prost(double, tag = "8")]
    pub actual_profit_usd: f64,
    #[prost(string, tag = "9")]
    pub error: String,
}

// System management
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemStatusRequest {}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemStatusResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub scanner_running: bool,
    #[prost(uint64, tag = "3")]
    pub uptime_seconds: u64,
    #[prost(uint32, tag = "4")]
    pub active_feeds: u32,
    #[prost(uint32, tag = "5")]
    pub tracked_pools: u32,
    #[prost(uint32, tag = "6")]
    pub tracked_tokens: u32,
    #[prost(uint64, tag = "7")]
    pub opportunities_found: u64,
    #[prost(uint64, tag = "8")]
    pub trades_executed: u64,
    #[prost(double, tag = "9")]
    pub total_profit_usd: f64,
    #[prost(uint64, tag = "10")]
    pub last_scan_duration_us: u64,
    #[prost(message, repeated, tag = "11")]
    pub chain_statuses: Vec<ChainStatus>,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainStatus {
    #[prost(enumeration = "Chain", tag = "1")]
    pub chain: i32,
    #[prost(bool, tag = "2")]
    pub connected: bool,
    #[prost(uint64, tag = "3")]
    pub last_block: u64,
    #[prost(uint32, tag = "4")]
    pub pool_count: u32,
    #[prost(uint64, tag = "5")]
    pub last_update_ms: u64,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConfigRequest {
    #[prost(uint64, optional, tag = "1")]
    pub scan_interval_ms: Option<u64>,
    #[prost(double, optional, tag = "2")]
    pub min_profit_usd: Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub min_confidence: Option<f64>,
    #[prost(double, optional, tag = "4")]
    pub max_gas_gwei: Option<f64>,
    #[prost(enumeration = "Chain", repeated, tag = "5")]
    pub enabled_chains: Vec<i32>,
    #[prost(enumeration = "DexProtocol", repeated, tag = "6")]
    pub enabled_dexes: Vec<i32>,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConfigResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartScannerRequest {
    #[prost(enumeration = "Chain", repeated, tag = "1")]
    pub chains: Vec<i32>,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartScannerResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopScannerRequest {}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopScannerResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: String,
}

// Service trait definition
#[tonic::async_trait]
pub trait DefiService: Send + Sync + 'static {
    async fn get_price(&self, request: Request<GetPriceRequest>) -> Result<Response<GetPriceResponse>, Status>;

    type StreamPricesStream: futures::Stream<Item = Result<PriceUpdate, Status>> + Send + 'static;
    async fn stream_prices(&self, request: Request<StreamPricesRequest>) -> Result<Response<Self::StreamPricesStream>, Status>;

    async fn get_opportunities(&self, request: Request<GetOpportunitiesRequest>) -> Result<Response<GetOpportunitiesResponse>, Status>;

    type StreamOpportunitiesStream: futures::Stream<Item = Result<ArbitrageOpportunity, Status>> + Send + 'static;
    async fn stream_opportunities(&self, request: Request<StreamOpportunitiesRequest>) -> Result<Response<Self::StreamOpportunitiesStream>, Status>;

    async fn simulate_trade(&self, request: Request<SimulateTradeRequest>) -> Result<Response<SimulateTradeResponse>, Status>;
    async fn simulate_route(&self, request: Request<SimulateRouteRequest>) -> Result<Response<SimulateRouteResponse>, Status>;

    async fn execute_trade(&self, request: Request<ExecuteTradeRequest>) -> Result<Response<ExecuteTradeResponse>, Status>;
    async fn get_trade_status(&self, request: Request<GetTradeStatusRequest>) -> Result<Response<GetTradeStatusResponse>, Status>;

    async fn get_system_status(&self, request: Request<GetSystemStatusRequest>) -> Result<Response<GetSystemStatusResponse>, Status>;
    async fn update_config(&self, request: Request<UpdateConfigRequest>) -> Result<Response<UpdateConfigResponse>, Status>;
    async fn start_scanner(&self, request: Request<StartScannerRequest>) -> Result<Response<StartScannerResponse>, Status>;
    async fn stop_scanner(&self, request: Request<StopScannerRequest>) -> Result<Response<StopScannerResponse>, Status>;
}

// Server builder
pub struct DefiServiceServer<T: DefiService> {
    inner: std::sync::Arc<T>,
}

impl<T: DefiService> DefiServiceServer<T> {
    pub fn new(inner: T) -> Self {
        Self {
            inner: std::sync::Arc::new(inner),
        }
    }

    pub fn from_arc(inner: std::sync::Arc<T>) -> Self {
        Self { inner }
    }
}

impl<T: DefiService> tonic::codegen::Service<http::Request<tonic::body::BoxBody>> for DefiServiceServer<T> {
    type Response = http::Response<tonic::body::BoxBody>;
    type Error = std::convert::Infallible;
    type Future = std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, _cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&mut self, _req: http::Request<tonic::body::BoxBody>) -> Self::Future {
        // Placeholder - tonic-build generates the proper routing
        Box::pin(async move {
            Ok(http::Response::builder()
                .status(200)
                .body(tonic::body::BoxBody::default())
                .unwrap())
        })
    }
}

impl<T: DefiService> Clone for DefiServiceServer<T> {
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl<T: DefiService> tonic::transport::NamedService for DefiServiceServer<T> {
    const NAME: &'static str = "defi.DefiService";
}
